---
title: "Vintage Forecasting System: Detailed Methodology"
subtitle: "Mathematical, Statistical, and Validation Deep Dive"
author: "Vintage Forecasts System"
date: today
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    theme: cosmo
    css: styles.css
    number-sections: true
execute:
  echo: true
  warning: false
  error: false
---

# Introduction

This document explains the mathematical and statistical methods used in the Vintage Forecasting System. For a full list of models, comparison tables, and assessment criteria, see the Appendix.

# 1. Data Model and Preprocessing

## 1.1. Data Structure

- **Panel data**: Each row = loan, vintage, seasoning month.
- **Key fields**: `loan_id`, `vintage_date`, `seasoning_month`, `charge_off_rate`, `charge_off_amount`, `outstanding_balance`, `term`, `fico_band`.

## 1.2. Data Cleaning and Validation

- **Date parsing**: All dates are converted to pandas `datetime`.
- **Missing values**: Critical fields must be present; others are imputed or flagged.
- **Outlier detection**: Loans with implausible values (e.g., negative balances) are flagged.
- **FICO band assignment**: Explicit cutoffs, e.g., 600-649, 650-699, etc.

```{python}
def assign_fico_band(fico):
    if fico >= 800: return '800+'
    elif fico >= 750: return '750-799'
    elif fico >= 700: return '700-749'
    elif fico >= 650: return '650-699'
    elif fico >= 600: return '600-649'
    else: return '<600'
```

# 2. Multi-Model Seasoning Curve Approach

## 2.1. Cohort Definition

- **Vintage**: All loans originated in a given month (or quarter).
- **Analysis**: Performed at (vintage, FICO band) level.

## 2.2. Cumulative and Incremental Charge-off Rates

- **Cumulative**:  
  $C_t = \frac{\sum_{i=1}^t \text{charge\_off\_amount}_i}{\text{original\_loan\_amount}}$
- **Incremental**:  
  $I_t = \frac{\text{charge\_off\_amount}_t}{\text{original\_loan\_amount}}$

## 2.3. Model Candidates

The system uses a multi-model approach, fitting and comparing several models (parametric curves, simple heuristics, and ensemble methods) to the cumulative charge-off data for each (vintage, FICO band) segment. See the Appendix for details.

## 2.4. Curve Fitting Procedure

- For each (vintage, FICO band), compute cumulative charge-off rates by seasoning month.
- Use nonlinear least squares (scipy.optimize.curve_fit) or linear regression to fit each curve.
- Goodness-of-fit: $R^2$, RMSE, visual inspection.
- Select best-fitting curve or ensemble for each segment.

```{python}
from scipy.optimize import curve_fit
import numpy as np

def weibull_cdf(t, alpha, beta):
    return 1 - np.exp(-(t / beta) ** alpha)

def lognormal_cdf(t, mu, sigma):
    from scipy.stats import norm
    return norm.cdf((np.log(t) - mu) / sigma)

def gompertz_cdf(t, a, b):
    return 1 - np.exp(-a * (np.exp(b * t) - 1) / b)

# Example fit:
t = np.arange(1, 37)
y = np.array([0.01, 0.02, 0.03, ...])  # Cumulative charge-off rates
params, _ = curve_fit(weibull_cdf, t, y, p0=[1.5, 20])
fitted = weibull_cdf(t, *params)
```

## 2.5. Model Assessment and Selection

For each model, the following are evaluated:

- **Goodness-of-fit**: $R^2$, RMSE, visual fit
- **Forecast stability**: Sensitivity to outliers, overfitting risk
- **Complexity**: Number of parameters, interpretability
- **Explainability**: Can the model's behavior be easily understood and justified?

A summary table is produced for each segment, showing the performance and characteristics of each model.

### Example Table: Model Comparison

| Model         | RMSE   | RÂ²     | # Params | Explainability | Notes                |
|---------------|--------|--------|----------|---------------|----------------------|
| Weibull CDF   | 0.012  | 0.98   | 2        | High          | Good fit, interpretable |
| Lognormal CDF | 0.013  | 0.97   | 2        | High          | Slightly underfits tail |
| Gompertz CDF  | 0.011  | 0.98   | 2        | High          | Best fit, similar to Weibull |
| Linear Trend  | 0.025  | 0.90   | 2        | Very High     | Underfits, but simple |
| Scaling       | 0.030  | 0.88   | 1        | Very High     | Simple financial scaling |
| Additive      | 0.028  | 0.89   | 1        | Very High     | Adds future expected CO% |
| Ensemble      | 0.011  | 0.98   | 4        | Medium        | Robust, less interpretable |

- If one model is clearly superior (accuracy, parsimony, and explainability), it is selected.
- If multiple models perform similarly, an ensemble or weighted average may be used to combine their forecasts, increasing robustness and trust.
- If models disagree significantly, this is flagged for further investigation and transparency in reporting.

# 3. Forecasting and Aggregation

## 3.1. Portfolio Quality Mix

- User specifies portfolio mix by FICO band (dollar-weighted).
- System supports scenario analysis (Conservative, Balanced, Aggressive).

## 3.2. Forward Projection

- For each FICO band, use fitted curve to project cumulative charge-off rates for each future month.
- Incremental charge-offs: $I_t = C_t - C_{t-1}$

## 3.3. Dollar-weighted Aggregation

$\text{Portfolio Charge-off}(t) = \sum_b w_b \cdot \text{Charge-off}_b(t)$

where $w_b$ is the portfolio share of FICO band $b$.

## 3.4. Scenario Analysis

- Multiple quality mixes and economic overlays can be specified.
- System outputs scenario-specific forecasts and risk metrics.

# 4. Model Validation and Backtesting

## 4.1. Goodness-of-Fit

- $R^2$, RMSE, and visual inspection of fit for each seasoning curve.
- Residual analysis for model misspecification.

## 4.2. Out-of-Sample Testing

- Holdout vintages are used to test predictive accuracy.
- Forecasts are compared to actual realized charge-offs.

## 4.3. Sensitivity Analysis

- Impact of changing FICO mix, seasoning curve parameters, and economic overlays is quantified.

# 5. Risk Metrics

- **Lifetime Loss Rate**: Total charge-offs / original portfolio balance.
- **Peak Charge-off Rate**: Maximum monthly incremental rate.
- **Volatility**: Standard deviation of monthly rates.
- **Concentration**: Herfindahl-Hirschman Index (HHI) for FICO and vintage.
- **Scenario Sensitivity**: Range of outcomes across scenarios.

# 6. Implementation Details

- All code is implemented in Python using pandas, numpy, scipy, and matplotlib.
- Data validation and error handling are performed at each step.
- The system is modular and extensible for new models or risk factors.

# 7. Limitations and Assumptions

- Assumes historical seasoning patterns are predictive of future performance.
- Does not model prepayment or recovery explicitly (can be extended).
- Economic overlays are scenario-based, not macro-driven (can be extended).

# 8. Future Work

- **Macroeconomic Integration**: Incorporate macroeconomic variables (e.g., unemployment, GDP, interest rates) if/when data is available, to allow for scenario-based or macro-driven forecasting.
- **Prepayment and Recovery Modeling**: Extend models to account for prepayments and recoveries, which can impact loss timing and magnitude.
- **Machine Learning Models**: Explore more complex models (e.g., gradient boosting, neural nets) if justified by data volume and need for accuracy, with careful attention to explainability.
- **Additional Features**: If data becomes available, consider incorporating borrower-level or loan-level features that may improve forecast accuracy, such as employment status, income, or geographic region.

# 9. References

- [Weibull Distribution](https://en.wikipedia.org/wiki/Weibull_distribution)
- [Gompertz Function](https://en.wikipedia.org/wiki/Gompertz_function)
- [Lognormal Distribution](https://en.wikipedia.org/wiki/Log-normal_distribution)
- [Vintage Analysis in Credit Risk](https://www.moodysanalytics.com/-/media/whitepaper/2017/2017-10-10-vintage-analysis.pdf)

# Appendix: Example Code

```{python}
# Example: Fitting a Weibull curve to cumulative charge-off data
from scipy.optimize import curve_fit

def weibull_cdf(t, alpha, beta):
    return 1 - np.exp(-(t / beta) ** alpha)

# t: array of seasoning months, y: cumulative charge-off rates
params, _ = curve_fit(weibull_cdf, t, y, p0=[1.5, 20])
fitted = weibull_cdf(t, *params)
``` 